<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>C:\Users\eroman\git\eurb\ocjp-exam\ocjp-exam\src\main\java\com\test\exam\ocjp\inner\classes\.InnerClasses.md.html</title>


<style type="text/css">
body {
	color: #333;
	font: 13px/1.4 "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
	padding: 0;
	margin: 0;
}

a {
	background: transparent;
	color: #4183c4;
	text-decoration: none;
}

a:active,
a:hover {
	outline: 0 none;
	text-decoration: underline;
}

abbr[title] {
	border-bottom: 1px dotted;
}

b,
strong {
	font-weight: bold;
}

dfn {
	font-style: italic;
}
h1 {
	font-size: 2em;
	margin: 0.67em 0;
}
mark {
	background: #ff0;
	color: #000;
}
small {
	font-size: 80%;
}
sub, sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}
sup {
	top: -0.5em;
}
sub {
	bottom: -0.25em;
}
img {
	border: 0 none;
}
svg:not(:root) {
	overflow: hidden;
}
figure {
	margin: 1em 40px;
}
hr {
	box-sizing: content-box;
	height: 0;
}

code,
kbd,
pre,
samp {
	font-family: monospace,monospace;
	font-size: 1em;
}

pre {
	overflow: auto;
	font: 12px Consolas,"Liberation Mono",Menlo,Courier,monospace;
	margin-bottom: 0;
	margin-top: 0;
}

.markdown-body {
	padding: 30px;
	font-size: 16px;
	line-height: 1.6;
	word-wrap: break-word;
}

.markdown-body>*:first-child {
	margin-top: 0 !important;
}

.markdown-body>*:last-child {
	margin-bottom: 0 !important;
}

.markdown-body .absent {
	color: #c00;
}

.markdown-body .anchor {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	display: block;
	padding-right: 6px;
	padding-left: 30px;
	margin-left: -30px;
}

.markdown-body .anchor:focus {
	outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	position: relative;
	margin-top: 1em;
	margin-bottom: 16px;
	font-weight: bold;
	line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
	display: none;
	color: #000;
	vertical-align: middle;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
	padding-left: 8px;
	margin-left: -30px;
	line-height: 1;
	text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
	display: inline-block;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
	font-size: inherit;
}

.markdown-body h1 {
	padding-bottom: 0.3em;
	font-size: 2.25em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}

.markdown-body h2 {
	padding-bottom: 0.3em;
	font-size: 1.75em;
	line-height: 1.225;
	border-bottom: 1px solid #eee;
}

.markdown-body h3 {
	font-size: 1.5em;
	line-height: 1.43;
}

.markdown-body h4 {
	font-size: 1.25em;
}

.markdown-body h5 {
	font-size: 1em;
}

.markdown-body h6 {
	font-size: 1em;
	color: #777;
}

.markdown-body p,.markdown-body blockquote,
.markdown-body ul,.markdown-body ol,
.markdown-body dl,.markdown-body table,
.markdown-body pre {
	margin-top: 0;
	margin-bottom: 16px;
}

.markdown-body hr {
	height: 4px;
	padding: 0;
	margin: 16px 0;
	background-color: #e7e7e7;
	border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 2em;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
	padding: 0;
	list-style-type: none;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body li>p {
	margin-top: 16px;
}

.markdown-body dl {
	padding: 0;
}

.markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: bold;
}

.markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
}

.markdown-body blockquote {
	padding: 0 15px;
	color: #777;
	border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
	margin-top: 0;
}

.markdown-body blockquote>:last-child {
	margin-bottom: 0;
}

.markdown-body table {
	display: block;
	width: 100%;
	overflow: auto;
	word-break: normal;
	word-break: keep-all;
}

.markdown-body table th {
	font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
	padding: 6px 13px;
	border: 1px solid #ddd;
}

.markdown-body table tr {
	background-color: #fff;
	border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
	background-color: #f8f8f8;
}

.markdown-body img {
	max-width: 100%;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

.markdown-body span.frame {
	display: block;
	overflow: hidden;
}

.markdown-body span.frame>span {
	display: block;
	float: left;
	width: auto;
	padding: 7px;
	margin: 13px 0 0;
	overflow: hidden;
	border: 1px solid #ddd;
}

.markdown-body span.frame span img {
	display: block;
	float: left;
}

.markdown-body span.frame span span {
	display: block;
	padding: 5px 0 0;
	clear: both;
	color: #333;
}

.markdown-body span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-center>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: center;
}

.markdown-body span.align-center span img {
	margin: 0 auto;
	text-align: center;
}

.markdown-body span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-right>span {
	display: block;
	margin: 13px 0 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body span.align-right span img {
	margin: 0;
	text-align: right;
}

.markdown-body span.float-left {
	display: block;
	float: left;
	margin-right: 13px;
	overflow: hidden;
}

.markdown-body span.float-left span {
	margin: 13px 0 0;
}

.markdown-body span.float-right {
	display: block;
	float: right;
	margin-left: 13px;
	overflow: hidden;
}

.markdown-body span.float-right>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body code,.markdown-body tt {
	padding: 0;
	padding-top: 0.2em;
	padding-bottom: 0.2em;
	margin: 0;
	font-size: 85%;
	background-color: rgba(0,0,0,0.04);
	border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after,
.markdown-body tt:before,
.markdown-body tt:after {
	letter-spacing: -0.2em;
	content: "\00a0";
}

.markdown-body code br,
.markdown-body tt br {
	display: none;
}

.markdown-body del code {
	text-decoration: inherit;
}

.markdown-body pre>code {
	padding: 0;
	margin: 0;
	font-size: 100%;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
}

.markdown-body .highlight {
	margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f7f7f7;
	border-radius: 3px;
}

.markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
}

.markdown-body pre {
	word-wrap: normal;
}

.markdown-body pre code,
.markdown-body pre tt {
	display: inline;
	max-width: initial;
	padding: 0;
	margin: 0;
	overflow: initial;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after,
.markdown-body pre tt:before,
.markdown-body pre tt:after {
	content: normal;
}

.highlight .pl-coc,
.highlight .pl-entl,
.highlight .pl-entm,
.highlight .pl-eoa,
.highlight .pl-mai .pl-sf,
.highlight .pl-mm,
.highlight .pl-pdv,
.highlight .pl-sc,
.highlight .pl-som,
.highlight .pl-sr,
.highlight .pl-v,
.highlight .pl-vpf {
	color: #0086b3;
}
.highlight .pl-eoac,
.highlight .pl-mdht,
.highlight .pl-mi1,
.highlight .pl-mri,
.highlight .pl-va,
.highlight .pl-vpu {
	color: #008080;
}
.highlight .pl-c,
.highlight .pl-pdc {
	color: #b4b7b4;
	font-style: italic;
}
.highlight .pl-k,
.highlight .pl-ko,
.highlight .pl-kolp,
.highlight .pl-mc,
.highlight .pl-mr,
.highlight .pl-ms,
.highlight .pl-s,
.highlight .pl-sok,
.highlight .pl-st {
	color: #6e5494;
}
.highlight .pl-ef,
.highlight .pl-enf,
.highlight .pl-enm,
.highlight .pl-entc,
.highlight .pl-eoi,
.highlight .pl-sf,
.highlight .pl-smc {
	color: #d12089;
}
.highlight .pl-ens,
.highlight .pl-eoai,
.highlight .pl-kos,
.highlight .pl-mh .pl-pdh,
.highlight .pl-mp,
.highlight .pl-pde,
.highlight .pl-stp {
	color: #458;
}
.highlight .pl-enti {
	color: #d12089;
	font-weight: bold;
}
.highlight .pl-cce,
.highlight .pl-enc,
.highlight .pl-kou,
.highlight .pl-mq {
	color: #f93;
}
.highlight .pl-mp1 .pl-sf {
	color: #458;
	font-weight: bold;
}
.highlight .pl-cos,
.highlight .pl-ent,
.highlight .pl-md,
.highlight .pl-mdhf,
.highlight .pl-ml,
.highlight .pl-pdc1,
.highlight .pl-pds,
.highlight .pl-s1,
.highlight .pl-scp,
.highlight .pl-sol {
	color: #df5000;
}
.highlight .pl-c1,
.highlight .pl-cn,
.highlight .pl-pse,
.highlight .pl-pse .pl-s2,
.highlight .pl-vi {
	color: #a31515;
}
.highlight .pl-mb,
.highlight .pl-pdb {
	color: #df5000;
	font-weight: bold;
}
.highlight .pl-mi,
.highlight .pl-pdi {
	color: #6e5494;
	font-style: italic;
}
.highlight .pl-ms1 {
	background-color: #f5f5f5;
}
.highlight .pl-mdh,
.highlight .pl-mdi {
	font-weight: bold;
}
.highlight .pl-mdr {
	color: #0086b3;
	font-weight: bold;
}
.highlight .pl-s2 {
	color: #333;
}
.highlight .pl-ii {
	background-color: #df5000;
	color: #fff;
}
.highlight .pl-ib {
	background-color: #f93;
}
.highlight .pl-id {
	background-color: #a31515;
	color: #fff;
}
.highlight .pl-iu {
	background-color: #b4b7b4;
}
.highlight .pl-mo {
	color: #969896;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h3> <a id="inner-classes-notes" class="anchor" href="#inner-classes-notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inner Classes Notes</h3> 
<p>You define an inner class within the curly braces of the outer class:</p> 
<div class="highlight highlight-source-java">
 <pre>   <span class="pl-k">class</span> <span class="pl-en">MyOuter</span> {
       <span class="pl-k">class</span> <span class="pl-en">MyInner</span> { }
   }</pre>
</div> 
<p>And if you compile it,</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">%</span>javac <span class="pl-smi">MyOuter</span><span class="pl-k">.</span>java</pre>
</div> 
<p>you'll end up with two class files:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-smi">MyOuter</span><span class="pl-k">.</span>class
    <span class="pl-smi">MyOuter</span>$<span class="pl-smi">MyInner</span><span class="pl-k">.</span>class</pre>
</div> 
<p>The <em>only way you can access the inner class is through a live instance of the outer class!</em>. In other words, only at runtime when there's already an instance of the outer class to tie the inner class instance to. for example:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter</span> {
        <span class="pl-k">private</span> <span class="pl-k">int</span> x <span class="pl-k">=</span> <span class="pl-c1">7</span>;
        <span class="pl-c"><span class="pl-c">//</span> inner class definition</span>
        <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
            }
        } <span class="pl-c"><span class="pl-c">//</span> close inner class definition</span>
    } <span class="pl-c"><span class="pl-c">//</span> close outer class</span></pre>
</div> 
<p>The preceding code is perfectly legal. Notice that the inner class is indeed accessing a private member of the outer class. That's fine, because the inner class is also a member of the outer class. So just as any member of the outer class (say, an instance method) can access any other member of the outer class, private or not, the inner class—also a member—can do the same.</p> 
<h5> <a id="instantiating-an-inner-class" class="anchor" href="#instantiating-an-inner-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Instantiating an Inner Class</h5> 
<p>To create an instance of an inner class, <em>you must have an instance of the outer class to tie to the inner class</em>. There are no exceptions to this rule: an inner class instance can never stand alone without a direct relationship to an instance of the outer class.</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter</span> {
        <span class="pl-k">private</span> <span class="pl-k">int</span> x <span class="pl-k">=</span> <span class="pl-c1">7</span>;
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">makeInner</span>() {
            <span class="pl-smi">MyInner</span> in <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyInner</span>(); <span class="pl-c"><span class="pl-c">//</span> make an inner instance</span>
            in<span class="pl-k">.</span>seeOuter();
        }
        <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
            }
        }
    }</pre>
</div> 
<p>You can see in the preceding code that the MyOuter code treats MyInner just as though MyInner were any other accessible class. But the only reason this syntax works is because the outer class instance method code is doing the instantiating. In other words, there's already an instance of the outer class—the instance running the makeInner() method.</p> 
<h5> <a id="creating-an-inner-class-object-from-outside-the-outer-class-instance-code" class="anchor" href="#creating-an-inner-class-object-from-outside-the-outer-class-instance-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating an Inner Class Object from Outside the Outer Class Instance Code</h5> 
<p>If we want to create an instance of the inner class, we must have an instance of the outer class. You already know that, but think about the implications…it means that, without a reference to an instance of the outer class, you can't instantiate the inner class from a static method of the outer class (because, don't forget, in static code there is no this reference), or from any other code in any other class. Inner class instances are always handed an implicit reference to the outer class. The compiler takes care of it, so you'll never see anything but the end result—the ability of the inner class to access members of the outer class. The code to make an instance from anywhere outside nonstatic code of the outer class is simple, but you must <strong>memorize this for the exam!</strong>:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> main(<span class="pl-k">String</span>[] args) {
        <span class="pl-smi">MyOuter</span> mo <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyOuter</span>(); <span class="pl-c"><span class="pl-c">//</span> gotta get an instance!</span>
        <span class="pl-smi">MyOuter</span><span class="pl-k">.</span><span class="pl-smi">MyInner</span> inner <span class="pl-k">=</span> mo<span class="pl-k">.</span><span class="pl-k">new</span> <span class="pl-smi">MyInner</span>();
        inner<span class="pl-k">.</span>seeOuter();
    }</pre>
</div> 
<p>The preceding code is the same regardless of whether the main() method is within the MyOuter class or some other class (assuming the other class has access to MyOuter, and since MyOuter has default access, that means the code must be in a class within the same package as MyOuter). If you're into one-liners, you can do it like this:</p> 
<div class="highlight highlight-source-java">
 <pre>   <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> main(<span class="pl-k">String</span>[] args) {
        <span class="pl-smi">MyOuter</span><span class="pl-k">.</span><span class="pl-smi">MyInner</span> inner <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyOuter</span>()<span class="pl-k">.</span><span class="pl-k">new</span> <span class="pl-smi">MyInner</span>();
        inner<span class="pl-k">.</span>seeOuter();
    }</pre>
</div> 
<p>You can think of this as though you're invoking a method on the outer instance, but the method happens to be a special inner class instantiation method, and it's invoked using the keyword new. Instantiating an inner class is the only scenario in which you'll invoke new on an instance as opposed to invoking new to construct an instance.</p> 
<p>But what if the inner class code wants an explicit reference to the outer class instance that the inner instance is tied to? In other words, how do you reference the &quot;outer this&quot;?</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter</span> {
        <span class="pl-k">private</span> <span class="pl-k">int</span> x <span class="pl-k">=</span> <span class="pl-c1">7</span>;
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">makeInner</span>() {
            <span class="pl-smi">MyInner</span> in <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyInner</span>();
            in<span class="pl-k">.</span>seeOuter();
        }
        <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
                <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Inner class ref is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> <span class="pl-c1">this</span>);
                <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer class ref is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> <span class="pl-smi">MyOuter</span><span class="pl-k">.</span><span class="pl-c1">this</span>);
            }
        }
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span> (<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
            <span class="pl-smi">MyOuter</span><span class="pl-k">.</span><span class="pl-smi">MyInner</span> inner <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyOuter</span>()<span class="pl-k">.</span><span class="pl-k">new</span> <span class="pl-smi">MyInner</span>();
            inner<span class="pl-k">.</span>seeOuter();
        }
    }</pre>
</div> 
<p>Con esta sintaxis del ejemplo podemos usar <em>this</em> para referirnos ya se a la clase interna o a la clase externa como se muestra en el m&eacute;todo <em>setOuter()</em>.</p> 
<p>So the rules for an inner class referencing itself or the outer instance are as follows:</p> 
<ol> 
 <li>To reference the inner class instance itself, from within the inner class code, use this.</li> 
 <li>To reference the &quot;outer this&quot; (the outer class instance) from within the inner class code, use NameOfOuterClass.this (example, MyOuter.this).</li> 
</ol> 
<h5> <a id="method-local-inner-classes" class="anchor" href="#method-local-inner-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Method-Local Inner Classes</h5> 
<p>A regular inner class is scoped inside another class's curly braces, but outside any method code (in other words, at the same level that an instance variable is declared). But you can also define an inner class within a method:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter2</span> {
        <span class="pl-k">private</span> <span class="pl-smi">String</span> x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">&quot;</span>Outer2<span class="pl-pds">&quot;</span></span>;
        <span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
            <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
                <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
                } <span class="pl-c"><span class="pl-c">//</span> close inner class method</span>
            } <span class="pl-c"><span class="pl-c">//</span> close inner class definition</span>
        } <span class="pl-c"><span class="pl-c">//</span> close outer class method doStuff()</span>
    } <span class="pl-c"><span class="pl-c">//</span> close outer class</span></pre>
</div> 
<p>The preceding code declares a class, MyOuter2, with one method, doStuff(). But inside doStuff(), another class, MyInner, is declared, and it has a method of its own, seeOuter(). Just because you declared the class doesn't mean you created an instance of it. So to use the inner class you must make an instance of it somewhere within the method but below the inner class definition (or the compiler won't be able to find the inner class). The following legal code shows how to instantiate and use a method-local inner class:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter2</span> {
        <span class="pl-k">private</span> <span class="pl-smi">String</span> x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">&quot;</span>Outer2<span class="pl-pds">&quot;</span></span>;
        <span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
            <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
                <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
                } <span class="pl-c"><span class="pl-c">//</span> close inner class method</span>
            } <span class="pl-c"><span class="pl-c">//</span> close inner class definition</span>
            <span class="pl-smi">MyInner</span> mi <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MyInner</span>(); <span class="pl-c"><span class="pl-c">//</span> This line must come</span>
            <span class="pl-c"><span class="pl-c">//</span> after the class</span>
            mi<span class="pl-k">.</span>seeOuter();
        } <span class="pl-c"><span class="pl-c">//</span> close outer class method doStuff()</span>
    } <span class="pl-c"><span class="pl-c">//</span> close outer class</span></pre>
</div> 
<p>A method-local inner class can be instantiated only within the method where the inner class is defined. In other words, no other code running in any other method—inside or outside the outer class—can ever instantiate the method-local inner class. Like regular inner class objects, the method-local inner class object shares a special relationship with the enclosing (outer) class object, and can access its private (or any other) members. However, the inner class object cannot use the local variables of the method the inner class is in. However, the inner class object cannot use the local variables of the method the inner class is in:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">class</span> <span class="pl-en">MyOuter2</span> {
        <span class="pl-k">private</span> <span class="pl-smi">String</span> x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">&quot;</span>Outer2<span class="pl-pds">&quot;</span></span>;
        <span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
            <span class="pl-smi">String</span> z <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">&quot;</span>local variable<span class="pl-pds">&quot;</span></span>;
            <span class="pl-k">class</span> <span class="pl-en">MyInner</span> {
                <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">seeOuter</span>() {
                    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Outer x is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> x);
                    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Local variable z is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> z); <span class="pl-c"><span class="pl-c">//</span> Won't Compile!</span>
                } <span class="pl-c"><span class="pl-c">//</span> close inner class method</span>
            } <span class="pl-c"><span class="pl-c">//</span> close inner class definition</span>
        } <span class="pl-c"><span class="pl-c">//</span> close outer class method doStuff()</span>
    } <span class="pl-c"><span class="pl-c">//</span> close outer class</span></pre>
</div> 
<p>Compiling the preceding code really upsets the compiler:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-smi">MyOuter2</span><span class="pl-k">.</span>java<span class="pl-k">:</span><span class="pl-c1">8</span><span class="pl-k">:</span> local variable z is accessed from within inner class;
    needs to be declared <span class="pl-k">final</span>
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>Local variable z is <span class="pl-pds">&quot;</span></span> <span class="pl-k">+</span> z);
                                                <span class="pl-k">^</span></pre>
</div> 
<p>Marking the local variable z as final fixes the problem:</p> 
<div class="highlight highlight-source-java">
 <pre>    <span class="pl-k">final</span> <span class="pl-smi">String</span> z <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">&quot;</span>local variable<span class="pl-pds">&quot;</span></span>; <span class="pl-c"><span class="pl-c">//</span> Now inner object can use it</span></pre>
</div> 
<p>Para usar una variable local dentro de una clase interna que este dentro de un m&eacute;todo como el ejemplo de arriba, debemos de marcar la varibale como final (quedar&iacute;a como constante) de lo contrario nos marcar&aacute; error de compulaci&oacute;n.</p> 
<p>And just a reminder about modifiers within a method: the same rules apply to method-local inner classes as to local variable declarations. You can't, for example, mark a method-local inner class public, private, protected, static, transient, and the like. For the purpose of the exam, the only modifiers you can apply to a method-local inner class are abstract and final, but as always, never both at the same time.</p> 
<h5> <a id="exam-watch" class="anchor" href="#exam-watch" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>exam watch</h5> 
<p>Remember that a local class declared in a static method has access to only static members of the enclosing class, since there is no associated instance of the enclosing class. If you're in a static method there is no this, so an inner class in a static method is subject to the same restrictions as the static method. In other words, no access to instance variables.</p> 
<h5> <a id="anonymous-inner-classes" class="anchor" href="#anonymous-inner-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Anonymous Inner Classes</h5> 
<p>The exam is littered with anonymous inner class code: you might see it on questions about threads, wrappers, overriding, garbage collection, and... well, you get the idea.</p> 
<h5> <a id="plain-old-anonymous-inner-classes-flavor-one" class="anchor" href="#plain-old-anonymous-inner-classes-flavor-one" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Plain-Old Anonymous Inner Classes, Flavor One</h5> 
<p>Check out the following legal-but-strange-the-first-time-you-see-it code:</p> 
<div class="highlight highlight-source-java">
 <pre> <span class="pl-k">class</span> <span class="pl-en">Popcorn</span> {
   <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">pop</span>() {
     <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>popcorn<span class="pl-pds">&quot;</span></span>);
   }
 }
 <span class="pl-k">class</span> <span class="pl-en">Food</span> {
   <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>() {
     <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">pop</span>() {
       <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>anonymous popcorn<span class="pl-pds">&quot;</span></span>);
     }
   };
 }</pre>
</div> 
<p>Let's look at what's in the preceding code:</p> 
<ul> 
 <li>We define two classes, Popcorn and Food.</li> 
 <li>Popcorn has one method, pop().</li> 
 <li>Food has one instance variable, declared as type Popcorn. That's it for Food. Food has no methods.</li> 
</ul> 
<p>And here's the big thing to get</p> 
<p>The Popcorn reference variable refers not to an instance of Popcorn, but to an instance of an anonymous (unnamed) subclass of Popcorn.</p> 
<p>Let's look at just the anonymous class code:</p> 
<div class="highlight highlight-source-java">
 <pre>
<span class="pl-c1">2.</span>   <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>() {
3.     public <span class="pl-k">void</span> <span class="pl-en">pop</span>() {
<span class="pl-c1">4.</span>       <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>anonymous popcorn<span class="pl-pds">&quot;</span></span>);
<span class="pl-c1">5.</span>     }
<span class="pl-c1">6.</span>   };
</pre>
</div> 
<p><strong>Line 2</strong> Line 2 starts out as an instance variable declaration of type Popcorn. But instead of looking like this:</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>(); <span class="pl-c"><span class="pl-c">//</span> notice the semicolon at the end</span></pre>
</div> 
<p>there's a curly brace at the end of line 2, where a semicolon would normally be.</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>() { <span class="pl-c"><span class="pl-c">//</span> a curly brace, not a semicolon</span></pre>
</div> 
<p>You can read line 2 as saying,</p> 
<p>Declare a reference variable, p, of type Popcorn. Then declare a new class that has no name, but that is a subclass of Popcorn. And here's the curly brace that opens the class definition…</p> 
<p><strong>Line 3</strong> Line 3, then, is actually the first statement within the new class definition. And what is it doing? Overriding the pop() method of the superclass Popcorn. This is the whole point of making an anonymous inner class—to override one or more methods of the superclass! (Or to implement methods of an interface, but we'll save that for a little later.)</p> 
<p><strong>Line 4</strong> Line 4 is the first (and in this case only) statement within the overriding pop() method. Nothing special there.</p> 
<p><strong>Line 5</strong> Line 5 is the closing curly brace of the pop() method. Nothing special.</p> 
<p><strong>Line 6</strong> Here's where you have to pay attention: line 6 includes a curly brace closing off the anonymous class definition (it's the companion brace to the one on line 2), but there's more! Line 6 also has the semicolon that ends the statement started on line 2—the statement where it all began—the statement declaring and initializing the Popcorn reference variable. And what you're left with is a Popcorn reference to a brand-new instance of a brand-new, just-in-time, anonymous (no name) subclass of Popcorn.</p> 
<p><a href="https://camo.githubusercontent.com/b4b73569a14210c5bf11579e8f2b70f9253c0f91/68747470733a2f2f692e696d6775722e636f6d2f68646f57726c692e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/b4b73569a14210c5bf11579e8f2b70f9253c0f91/68747470733a2f2f692e696d6775722e636f6d2f68646f57726c692e6a7067" alt="Imgur" data-canonical-src="https://i.imgur.com/hdoWrli.jpg" style="max-width:100%;" /></a></p> 
<p>Polymorphism is in play when anonymous inner classes are involved. Remember that, as in the preceding Popcorn example, we're using a superclass reference variable type to refer to a subclass object. What are the implications? You can only call methods on an anonymous inner class reference that are defined in the reference variable type! This is no different from any other polymorphic references, for example,</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-k">class</span> <span class="pl-en">Horse</span> <span class="pl-k">extends</span> <span class="pl-e">Animal</span>{
    <span class="pl-k">void</span> <span class="pl-en">buck</span>() { }
  }
  
  <span class="pl-k">class</span> <span class="pl-en">Animal</span> {
    <span class="pl-k">void</span> <span class="pl-en">eat</span>() { }
  }
  
  <span class="pl-k">class</span> <span class="pl-en">Test</span> {
     <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span> (<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-smi">Animal</span> h <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Horse</span>();
        h<span class="pl-k">.</span>eat(); <span class="pl-c"><span class="pl-c">//</span> Legal, class Animal has an eat() method</span>
        h<span class="pl-k">.</span>buck(); <span class="pl-c"><span class="pl-c">//</span> Not legal! Class Animal doesn't have buck()</span>
     }
  }</pre>
</div> 
<p>So on the exam, you must be able to spot an anonymous inner class that— rather than overriding a method of the superclass—defines its own new method. The method definition isn't the problem, though; the real issue is how do you invoke that new method? The reference variable type (the superclass) won't know anything about that new method (defined in the anonymous subclass), so the compiler will complain if you try to invoke any method on an anonymous inner class reference that is not in the superclass class definition. Check out the following, illegal code:</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-k">class</span> <span class="pl-en">Popcorn</span> {
     <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">pop</span>() {
       <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>popcorn<span class="pl-pds">&quot;</span></span>);
     }
  }
  <span class="pl-k">class</span> <span class="pl-en">Food</span> {
    <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>() {
      <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">sizzle</span>() {
         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>anonymous sizzling popcorn<span class="pl-pds">&quot;</span></span>);
      }
      <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">pop</span>() {
         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>anonymous popcorn<span class="pl-pds">&quot;</span></span>);
      } 
    };
    
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">popIt</span>() {
       p<span class="pl-k">.</span>pop(); <span class="pl-c"><span class="pl-c">//</span> OK, Popcorn has a pop() method</span>
       p<span class="pl-k">.</span>sizzle(); <span class="pl-c"><span class="pl-c">//</span> Not Legal! Popcorn does not have sizzle()</span>
    }
 }</pre>
</div> 
<p>which is the compiler's way of saying, &quot;I can't find method sizzle() in class Popcorn,&quot; followed by, &quot;Get a clue.&quot;</p> 
<h5> <a id="plain-old-anonymous-inner-classes-flavor-two" class="anchor" href="#plain-old-anonymous-inner-classes-flavor-two" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Plain-Old Anonymous Inner Classes, Flavor Two</h5> 
<p>The only difference between flavor one and flavor two is that flavor one creates an anonymous subclass of the specified class type, whereas flavor two creates an anonymous implementer of the specified interface type. In the previous examples, we defined a new anonymous subclass of type Popcorn as follows:</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-smi">Popcorn</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Popcorn</span>() {</pre>
</div> 
<p>But if Popcorn were an interface type instead of a class type, then the new anonymous class would be an implementer of the interface rather than a subclass of the class. Look at the following example:</p> 
<div class="highlight highlight-source-java">
 <pre>   <span class="pl-k">interface</span> <span class="pl-en">Cookable</span> {
      <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">cook</span>();
   }
   <span class="pl-k">class</span> <span class="pl-en">Food</span> {
      <span class="pl-smi">Cookable</span> c <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Cookable</span>() {
         <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">cook</span>() {
             <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>anonymous cookable implementer<span class="pl-pds">&quot;</span></span>);
         }
      };
   }</pre>
</div> 
<p>The preceding code, like the Popcorn example, still creates an instance of an anonymous inner class, but this time the new just-in-time class is an implementer of the Cookable interface. And note that this is the only time you will ever see the syntax</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-k">new</span> <span class="pl-smi">Cookable</span>()</pre>
</div> 
<p>where Cookable is an interface rather than a nonabstract class type. Because think about it, you can't instantiate an interface, yet that's what the code looks like it's doing. But of course it's not instantiating a Cookable object, it's creating an instance of a new, anonymous, implementer of Cookable. You can read this line:</p> 
<div class="highlight highlight-source-java">
 <pre>     <span class="pl-smi">Cookable</span> c <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Cookable</span>() {</pre>
</div> 
<p>as, &quot;Declare a reference variable of type Cookable that, obviously, will refer to an object from a class that implements the Cookable interface. But, oh yes, we don't yet have a class that implements Cookable, so we're going to make one right here, right now. We don't need a name for the class, but it will be a class that implements Cookable, and this curly brace starts the definition of the new implementing class.&quot;</p> 
<p>One more thing to keep in mind about anonymous interface implementers—they can implement only one interface. There simply isn't any mechanism to say that your anonymous inner class is going to implement multiple interfaces. In fact, an anonymous inner class can't even extend a class and implement an interface at the same time. The inner class has to choose either to be a subclass of a named class— and not directly implement any interfaces at all—or to implement a single interface. By directly, we mean actually using the keyword implements as part of the class declaration. If the anonymous inner class is a subclass of a class type, it automatically becomes an implementer of any interfaces implemented by the superclass.</p> 
<p><a href="https://camo.githubusercontent.com/0f98ca598e540c94ba4d366c0d9028249ce65cda/68747470733a2f2f692e696d6775722e636f6d2f51784b62424f692e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/0f98ca598e540c94ba4d366c0d9028249ce65cda/68747470733a2f2f692e696d6775722e636f6d2f51784b62424f692e6a7067" alt="Imgur" data-canonical-src="https://i.imgur.com/QxKbBOi.jpg" style="max-width:100%;" /></a></p> 
<h5> <a id="argument-defined-anonymous-inner-classes" class="anchor" href="#argument-defined-anonymous-inner-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Argument-Defined Anonymous Inner Classes</h5> 
<p>You simply define an anonymous inner class, right inside the argument. That's right, just where you least expect to find a class. And here's what it looks like:</p> 
<div class="highlight highlight-source-java">
 <pre><span class="pl-c1">1.</span> <span class="pl-k">class</span> <span class="pl-en">MyWonderfulClass</span> {
2.   <span class="pl-k">void</span> <span class="pl-en">go</span>() {
<span class="pl-c1">3.</span>     <span class="pl-smi">Bar</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Bar</span>();
<span class="pl-c1">4.</span>     b<span class="pl-k">.</span>doStuff(<span class="pl-k">new</span> <span class="pl-smi">Foo</span>() {
5.       public <span class="pl-k">void</span> <span class="pl-en">foof</span>() {
<span class="pl-c1">6.</span>         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>foofy<span class="pl-pds">&quot;</span></span>);
<span class="pl-c1">7.</span>       } <span class="pl-c"><span class="pl-c">//</span> end foof method</span>
<span class="pl-c1">8.</span>     }); <span class="pl-c"><span class="pl-c">//</span> end inner class def, arg, and b.doStuff stmt.</span>
<span class="pl-c1">9.</span>    } <span class="pl-c"><span class="pl-c">//</span> end go()</span>
<span class="pl-c1">10.</span> } <span class="pl-c"><span class="pl-c">//</span> end class</span>
<span class="pl-c1">11.</span>
<span class="pl-c1">12.</span> <span class="pl-k">interface</span> <span class="pl-en">Foo</span> {
13.   <span class="pl-k">void</span> <span class="pl-en">foof</span>();
<span class="pl-c1">14.</span> }
<span class="pl-c1">15.</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span> {
16.   <span class="pl-k">void</span> <span class="pl-en">doStuff</span>(<span class="pl-smi">Foo</span> <span class="pl-v">f</span>) { }
<span class="pl-c1">17.</span> }</pre>
</div> 
<p>All the action starts on line 4. We're calling doStuff() on a Bar object, but the method takes an instance that IS-A Foo, where Foo is an interface. So we must make both an implementation class and an instance of that class, all right here in the argument to doStuff(). So that's what we do. We write</p> 
<div class="highlight highlight-source-java">
 <pre>   <span class="pl-k">new</span> <span class="pl-smi">Foo</span>() {</pre>
</div> 
<p>to start the new class definition for the anonymous class that implements the Foo interface. Foo has a single method to implement, foof(), so on lines 5, 6, and 7 we implement the foof() method. Then on line 8—whoa!—more strange syntax appears. The first curly brace closes off the new anonymous class definition. But don't forget that this all happened as part of a method argument, so the close parenthesis, ), finishes off the method invocation, and then we must still end the statement that began on line 4, so we end with a semicolon. Study this syntax! You will see anonymous inner classes on the exam, and you'll have to be very, very picky about the way they're closed. If they're argument local, they end like this:</p> 
<p>});</p> 
<p>but if they're just plain-old anonymous classes, then they end like this:</p> 
<p>};</p> 
<p>Regardless, the syntax is not what you use in virtually any other part of Java, so be careful. Any question from any part of the exam might involve anonymous inner classes as part of the code.</p> 
<h5> <a id="static-nested-classes" class="anchor" href="#static-nested-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Static Nested Classes</h5> 
<p>It is simply a non-inner (also called &quot;top-level&quot;) class scoped within another. So with static classes it's really more about name-space resolution than about an implicit relationship between the two classes.</p> 
<p>A static nested class is simply a class that's a static member of the enclosing class:</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-k">class</span> <span class="pl-en">BigOuter</span> {
     <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-en">Nested</span> { }
  }</pre>
</div> 
<p>The class itself isn't really &quot;static&quot;; there's no such thing as a static class. The static modifier in this case says that the nested class is a static member of the outer class. That means it can be accessed, as with other static members, without having an instance of the outer class.</p> 
<h5> <a id="instantiating-and-using-static-nested-classes" class="anchor" href="#instantiating-and-using-static-nested-classes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Instantiating and Using Static Nested Classes</h5> 
<p>You use standard syntax to access a static nested class from its enclosing class. The syntax for instantiating a static nested class from a non-enclosing class is a little different from a normal inner class, and looks like this:</p> 
<div class="highlight highlight-source-java">
 <pre>  <span class="pl-k">class</span> <span class="pl-en">BigOuter</span> {
    <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-en">Nest</span> {<span class="pl-k">void</span> <span class="pl-en">go</span>() { <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>hi<span class="pl-pds">&quot;</span></span>); } }
  }
  <span class="pl-k">class</span> <span class="pl-en">Broom</span> {
    <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-en">B2</span> {<span class="pl-k">void</span> <span class="pl-en">goB2</span>() { <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">&quot;</span>hi 2<span class="pl-pds">&quot;</span></span>); } }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
      <span class="pl-smi">BigOuter</span><span class="pl-k">.</span><span class="pl-smi">Nest</span> n <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">BigOuter</span>.<span class="pl-smi">Nest</span>(); <span class="pl-c"><span class="pl-c">//</span> both class names</span>
      n<span class="pl-k">.</span>go();
      <span class="pl-smi">B2</span> b2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">B2</span>(); <span class="pl-c"><span class="pl-c">//</span> access the enclosed class</span>
      b2<span class="pl-k">.</span>goB2();
    }
  }</pre>
</div> 
<p>Which produces hi hi 2</p> 
<h5> <a id="watch-exam" class="anchor" href="#watch-exam" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Watch exam</h5> 
<p>Just as a static method does not have access to the instance variables and nonstatic methods of the class, a static nested class does not have access to the instance variables and nonstatic methods of the outer class. Look for static nested classes with code that behaves like a nonstatic (regular inner) class.</p>
</body>
</html>
